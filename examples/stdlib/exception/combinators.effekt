module examples/pos/exception/combinators

import exception

def main() = {
  val str = "Hallo"

  // Test for default handling of OutOfBoundsException
  def defaultOutOfBounds { p: => Char / Exception[OutOfBounds] }: Unit = {
    with on[OutOfBounds].default { println("Index Out of Bound") }
    println(p().show)
  }

  defaultOutOfBounds { str.charAt(10) } // Index Out of Bound
  defaultOutOfBounds { str.charAt(1) } // a

  // Test for ignoring OutOfBoundsException
  def ignoreOutOfBounds { p: => Char / Exception[OutOfBounds] }: Unit = {
    with on[OutOfBounds].ignore();
    println(p().show) 
  }
  
  ignoreOutOfBounds { str.charAt(10) } // This will ignore the OutOfBoundsException
  ignoreOutOfBounds { str.charAt(1) } // a

  // Test for reporting OutOfBoundsException
  def reportOutOfBounds { p: => Char / Exception[OutOfBounds] }: Unit = {
    with on[OutOfBounds].report();
    println(p().show) 
    
  }

  reportOutOfBounds { str.charAt(10) } // Index out of bounds: 10 in string: 'Hallo'
  reportOutOfBounds { str.charAt(1) }  // a

  
  /*def finalizeOutOfBounds { p: => Char / Exception[OutOfBounds] }: Unit = {
    with on[OutOfBounds].finalize { println("Finalizer executed") }
    println(p().show) 
    
  
  }

  finalizeOutOfBounds { str.charAt(10) } // Finalizer executed \n a
  finalizeOutOfBounds { str.charAt(1) } // Finalizer will execute even without exception
  */
  //!! This somehow causes : Main cannot have effects, but includes effects: { Exception[OutOfBounds] }
}

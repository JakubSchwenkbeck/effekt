module examples/pos/exception/combinators

import exception

/**
 * Used as a type for `Exception` purely for independent testing
 */
record TestException()

def testException(): Nothing / Exception[TestException] =
  do raise(TestException(), "Test Exception.")



def main() : Unit = {
  // Test for default handling of Test Exception
  def defaultTestException { p: => String / Exception[TestException] }: Unit = {
    with on[TestException].default { println("Exception handled by default combinator") }
    println(p().show) 
  }

  defaultTestException { testException() } // Exception
  defaultTestException { "World" } // World

  // Test for ignoring TestExceptionException
  def ignoreTestException { p: => String / Exception[TestException] }: Unit = {
    with on[TestException].ignore();
    println(p().show) 
  }

  ignoreTestException { testException() } // ignored
  ignoreTestException { "World" } // World

  // Test for reporting TestExceptionException
  def reportTestException { p: => String / Exception[TestException] }: Unit = {
    with on[TestException].report();
    println(p().show) 
  }

  reportTestException { testException() } // Test Exception.
  reportTestException { "World" }  // World

  // Test for finalizing TestExceptionException
  def finalizeTestException { p: => String / Exception[TestException] }: Unit = {
    try {
      with on[TestException].finalize { println("Finalizer executed") }
      println(p().show) // Run the operation that might throw an exception
    } with exc : Exception[TestException] { def exc::raise(exception, msg) = () } // Ignore the exception
  }

  finalizeTestException { testException() } // Finalizer executed with exception
  finalizeTestException { "World" } // World + Finalizer will execute even without exception
}
